#'@title Function to fit entry-wise lm on tensor regression
#'
#'@param l  wavelet coefficient index
#'@param j  covariate index
#'@param xi condition index
#'@param Y observed tensor
#'@param X observed covariate

parse_lm_fit <- function(j,l,xi, v1,Y,X)
{

  out <- fast_lm(cbind(v1,X[,j]),Y[,l,xi])
  return(c(out$be[2,1],
           sqrt(
             var(out$residuals)/sum(
               (X[,j]-mean(X[,j]))^2)
           )
  )
  )
}



#' @title Regress column l and condition of Y on column j of X
#'
#' @description Add description here.
#'
#' @param Y  tensor phenotype, matrix of size N by size J by xi. The underlying algorithm uses wavelets that assume that J is of the form J^2. If J is not a power of 2, susiF internally remaps the data into a grid of length 2^J
#'
#' @param X matrix of size n by p in
#'
#' @param v1 vector of 1 of length n
#'
#' @return list of two tensor of size pxTx xi of 2 containing the regression coefficient and standard error
#'
#' @importFrom stats var
#'
#' @export
#'


cal_Bhat_Shat_tensor  <- function(Y, X, v1)
{
  Bhat  <- list()
  Shat  <- list()
  h <- 1 # looping index
  #need to parse by variable  (most inside loop) then by wave coef then by condition
  for (xi in 1:dim(Y)[3])
  {
    for ( l in 1:dim(Y)[2])
    {
      out <-  do.call( cbind,lapply( 1:dim(X)[2], function(j) parse_lm_fit( j=j,l=l,xi=xi,v1=v1, Y=DW_tens, X=X ) ) )
      Bhat[[h]]  <- out[1,]
      Shat[[h]] <- out[2,]
      h <- h+1
    }
  }

  tens_Bhat <- array( do.call(c, Bhat), dim = c( ncol(X),dim(Y)[2], dim(Y)[3]) )
  tens_Shat <- array( do.call(c, Shat), dim = c( ncol(X),dim(Y)[2], dim(Y)[3]) )

  out <- list( tens_Bhat = tens_Bhat,
               tens_Shat = tens_Shat)
  return(out)
}






#' @title Method to fit mash
#'
#' @description Method to fit mash
#'
#' @param Bhat  matrix of the regression coefficient (MLE)
#' @param Shat  matrix of standard error
#' @param data.driven logical, if TRUE use data driven covariance matrix procedure for fitting mash otherwise uses  cov_canonical method mashr. Set as TRUE by default
#'
#' @return a mash object
#'
#' @importFrom mashr mash_set_data
#' @importFrom mashr mash_1by1
#' @importFrom mashr get_significant_results
#' @importFrom mashr cov_pca
#' @importFrom mashr cov_ed
#' @importFrom mashr cov_canonical
#' @importFrom mashr mash
#'
#' @export
#'


basic_mash_fit <- function (Bhat, Shat, data.driven=TRUE)
{
  data   = mash_set_data( Bhat,  Shat)

  if( data.driven)
  {
    m.1by1 = mash_1by1(data)
    strong = get_significant_results(m.1by1,0.05)
    if( !(length(strong)==0))
    {
      U.pca  = cov_pca(data,
                       npc=length(strong),
                       subset=strong
      )
      #Problem with TPCa being NAN
      U.ed   = cov_ed(data, U.pca, subset=strong)
      U.c    = cov_canonical(data)
      m      = mash(data, c(U.c,U.ed))
    }else{
      U.c    = cov_canonical(data)
      m      = mash(data, c(U.c))
    }
  }else{
    U.c    = cov_canonical(data)
    m      = mash(data, c(U.c))
  }


  return(m)
}





#' @title Fit mash for a given set of wavelet coefficients
#'
#' @description Fit mash for a given set of wavelet coefficients
#'
#' @param tens_marg list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#'
#' @param s scale of interest
#'
#' @param data.driven logical, if TRUE use data driven covariance matrix procedure for fitting mash otherwise uses  cov_canonical method mashr. Set as TRUE by default
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution
#'
#' @return a mash object
#'
#' @export
#'


fit_mash_level <- function(tens_marg, s, indx_lst, data.driven=TRUE)
{



  Bhat <- cbind_3Darray( tens_marg$tens_Bhat[,indx_lst[[s]],] )
  Shat <- cbind_3Darray( tens_marg$tens_Shat[,indx_lst[[s]],] )


  m <- basic_mash_fit(Bhat, Shat, data.driven = data.driven)

}


#' @title Compute Log-Bayes Factor of given scale and covariate for multivariate wavelet regression
#'
#' @description   Compute Log-Bayes Factor of given scale and covariate for multivariate wavelet regression
#'
#' @param G_prior a scale specific mash prior
#'
#' @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#'
#' @param s scale of interest
#'
#' @param j  covariate of interest
#'
#' @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#'   for the given level of resolution
#'
#' @return The log-Bayes factor of the given scale and covariate
#'
#' @export
#'

cal_lbf_mvfsusie_level <-  function(G_prior, tens_marg,s ,j , indx_lst)
{


  Bhat   <-   matrix(tens_marg$tens_Bhat[j,indx_lst[[s]],],ncol = dim(tens_marg$tens_Bhat)[3])
  Shat   <-   matrix(tens_marg$tens_Shat[j,indx_lst[[s]],],ncol = dim(tens_marg$tens_Bhat)[3])
  data   <-   mash_set_data( Bhat,  Shat)
  m      <-   G_prior[[s]]

  loglik      <-  sum (mash_compute_vloglik(m,data))
  null_loglik <-  mvfsusie_compute_null_loglik(Bhat,Shat)
  lbf         <-   loglik -null_loglik

  return(lbf)
}

#' @title Compute Log-Bayes Factor of a given   covariate for multivariate wavelet regression
#'
#' @description   Compute Log-Bayes Factor of a given   covariate for multivariate wavelet regression
#'
#' @param G_prior a scale specific mash prior
#'
#' @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#'
#' @param s scale of interest
#'
#' @param j  covariate of interest
#'
#' @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#'   for the given level of resolution
#'
#' @return The log-Bayes factor for the considered covariate.
#'
#' @export
#'

cal_lbf_cov_mvsusie <- function(G_prior,tens_marg,s,j,indx_lst)
{
  #sum over the level specific Bayes Factor
  out <- do.call(sum,
                 lapply ( 1:length(indx_lst),
                          function(s) cal_lbf_mvfsusie_level (G_prior,
                                                              tens_marg,
                                                              s,
                                                              j,
                                                              indx_lst
                                                              )
                        )
                )
  return(out)
}


#' @title Compute Log-Bayes Factor for multivariate wavelet regression
#'
#' @description  Compute Log-Bayes Factor for multivariate wavelet regression using a scale specific mash prior
#'
#' @param G_prior a scale specific mash prior
#'
#' @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#'
#' @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#'   for the given level of resolution
#'
#' @return The log-Bayes factor for each covariate.
#'
#' @export
#'
log_BF_tens <- function( G_prior, tens_marg, indx_lst){


  out <-  do.call(c,
                  lapply( 1:dim( tens_marg$tens_Bhat)[1], #number of covariate
                       function(j) cal_lbf_cov_mvsusie (G_prior,
                                                        tens_marg,
                                                        s,
                                                        j,
                                                        indx_lst
                                                        )
                       )
               )

 return(out)
}


#' @title Compute log likelihood of multivariate gaussian model under the null
#'
#' @description  Compute log likelihood of multivariate gaussian model under the null
#'
#' @param Bhat a matrix (n_wavelet_coef x n_cond)  of MLE mean estimate
#'
#' @param Shat a matrix (n_wavelet_coef x n_cond)  of MLE sd estimate
#'
#' @return The log likelihood
#'
#' @export
#'
mvfsusie_compute_null_loglik <- function(Bhat,Shat)
{

 out <- do.call(sum,
                lapply( 1:nrow(Bhat),
                        function(i) dmvnorm(x=(Bhat[i,]),
                                            mean= rep(0,length(Bhat[i,])),
                                            sigma= diag((Shat[i,])^2),
                                            log=TRUE)
                        )
                )
 return(out)


}






#' @title EM algorithm to select mixture weight in a  Empirical Bayes way
#'
#' @description Select the mixture wieght by maximizing the marginal likelihood
#'
#'
#' @param G_prior a scale specific mash prior
#'
#' @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#'
#' @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#'   for the given level of resolution
#'
#' @param max_step numeric, maximum number of EM iteration
#'
#'
#' @param espsilon numeric, tolerance EM algorithm
#'
#' @return
#'\item{tpi_k}{ fitted mixture proportion}
#'\item{lBF}{ log Bayes Factor}
#'
#' @export
#'
EM_pi_mvfsusie <- function(G_prior,tens_marg, indx_lst,
                            max_step = 100,
                            espsilon = 0.0001){

  #static parameters
  Lmat  <-  L_mixsq_mvfsusie(G_prior, tens_marg, indx_lst)
  J <- dim(Bhat)[1]
  tsd_k <- get_sd_G_prior(G_prior)

  #dynamic parameters
  tpi_k = get_pi_G_prior(G_prior)
  oldloglik <-0
  newloglik <-1

  zeta <- rep(1/J,J) #assignation initial value
  k <- 1 #counting the number of iteration

  lBF <- log_BF_tens  ( G_prior, tens_marg, indx_lst)

  while( k <max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    # E step----
    oldloglik <- cal_lik(lBF,zeta)
    zeta      <- cal_zeta(lBF)

    # M step ----
    tpi_k   <- m_step(Lmat,zeta,indx_lst)
    G_prior <- update_prior(G_prior,tpi_k)

    lBF <- log_BF_tens  ( G_prior, tens_marg, indx_lst)
    newloglik <- cal_lik(lBF,zeta)
    k <- k+1

  }

  out <- list(tpi_k = tpi_k,lBF = lBF)
  class(out) <- c("EM_pi","list")
  return(out)
}

#'@title Compute likelihood matrix for mixsqp
#'
#' @description Compute likelihood matrix for mixsqp
#'
#' @param G_prior a scale specific mash prior
#'
#' @param tens_marg a list of tensor of marginal association generated by \code{cal_Bhat_Shat_tensor}
#'
#' @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#'   for the given level of resolution
#'
#' @return See L argument mixsqp package mixsqp function
#'
#' @export
L_mixsq_mvfsusie <- function(G_prior, tens_marg, indx_lst)
{

}



L_mixsq_mvfsusie_scale <- function(G_prior, tens_marg, indx_lst,s)
{
  grid <- get_grid (G_prior , 2)
  Ulist <-  get_Ulist (G_prior , 2)
  xUlist = utils::getFromNamespace("expand_cov", "mashr")(Ulist,grid,usepointmass=TRUE)

  L_mat <-   utils::getFromNamespace("calc_relative_lik_matrix", "mashr")(data = data, xUlist) # allow using unexported function

}


