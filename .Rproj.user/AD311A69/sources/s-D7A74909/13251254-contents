multivariate_regression = function (bhat, S, U, S_inv) {
  if (is.numeric(S_inv))
    S_inv = lapply(1:length(S),function(j) invert_via_chol(S[[j]]))
  post_cov = lapply(1:length(S),
                    function(j) U %*% solve(diag(nrow(U)) + S_inv[[j]] %*% U))
  lbf = sapply(1:length(S),
               function(j) (log(det(S[[j]])) - log(det(S[[j]] + U)))/2 +
                 t(bhat[j,]) %*% S_inv[[j]] %*%
                 post_cov[[j]] %*% S_inv[[j]] %*% bhat[j,]/2)
  lbf[which(is.nan(lbf))] = 0
  
  # Using rbind here will end up with dimension issues for degenerated
  # case on J; have to use t(...(cbind, )) instead.
  post_b1 = t(do.call(cbind,lapply(1:length(S),
                                   function(j) post_cov[[j]] %*% (S_inv[[j]] %*% bhat[j,]))))
  post_b2 = lapply(1:length(post_cov),
                   function(j) tcrossprod(post_b1[j,]) + post_cov[[j]])
  
  # Deal with degerate case with one condition.
  if (ncol(post_b1) == 1)
    post_b2 = matrix(unlist(post_b2),length(post_b2),1)
  else
    post_b2 = aperm(abind(post_b2, along = 3),c(2,1,3))
  return(list(b1 = post_b1,b2 = post_b2,lbf = lbf,cov = post_cov))
}
invert_via_chol = function (x) {
  if (all(x == 0))
    return(list(inv = x,rank = 0))
  else
    return(list(inv = chol2inv(muffled_chol(x)),rank = nrow(x)))
}
# chol decomposition without warning message.
muffled_chol = function (x, ...)
  withCallingHandlers(chol(x, ...),
                      warning = function (w) {
                        if (grepl("the matrix is either rank-deficient or indefinite",w$message))
                          invokeRestart("muffleWarning")
                      })