
#' @title Initialize a multsusie object
#'
#' @param L number of non zero coefficients An L-vector containing the indices of the
#'   nonzero coefficients.
#'
#' @param G_prior prior object defined by init_prior_multsusie function
#'
#' @param Y list of matrices of outcomes
#'
#' @param X Matrix of covariates
#' @pama type_mark an object generated by \code{\link{is.functional}} function
#'
#' @return A list with the following elements
#' \item{fitted_wc}{ list of length L, each element contains the fitted wavelet coefficients of effect l}
#' \item{fitted_wc2}{list of length L, each element contains the variance of the fitted wavelet coefficients of effect l}
#' \item{alpha_hist}{ history of the fitted alpha value}
#' \item{N}{ number of indidivual in the study}
#' \item{sigma2}{residual variance}
#' \item{n_wac}{number of wavelet coefficients}
#' \item{ind_fitted_func}{fitted curves of each individual }
#' \item{cs}{credible set}
#' \item{pip}{Posterior inclusion probabilites}
#' \item{G_prior}{a G_prior of the same class as the input G_prior, used for internal calculation}
#' \item{lBF}{ log Bayes factor for the different effect}
#' \item{KL}{ the KL divergence for the different effect}
#' \item{ELBO}{ The evidence lower bound}
#' \item{lfsr_wc}{Local fasle sign rate of the fitted wavelet coefficients}
#' @export
init_multfsusie_obj <- function(L, G_prior, Y,X , type_mark)
{

  if(!is.null(Y$Y_f)){
  fitted_wc       <-  list()
  fitted_wc2      <-  list()
  n_wac           <-  lapply(lapply(Y$Y_f,dim) ,`[[`, 2)
  }else {
    fitted_wc       <-  NULL
    fitted_wc2      <-  NULL
    n_wac           <-  NULL
  }
  if(!is.null(Y$Y_u)){
    fitted_uni        <-   list()
    fitted_uni2       <-   list()
  }else{
    fitted_uni        <-   NULL
    fitted_uni2       <-   NULL
  }
  alpha           <-  list()
  alpha_hist      <-  list()
  ind_fitted_val  <-  list()
  cs              <-  list()
  pip             <-  rep(0, dim(X)[2])
  est_pi          <-  list()
  est_sd          <-  list()
  L               <-  L
  G_prior         <-  G_prior
  N               <-  nrow(X)[1]
  n_cond          <-  type_mark$ncond
  P               <-  ncol(X)[2]
  sigma2          <-  rep(1, length(Y))
  lBF             <-  list()
  KL              <-  rep(NA,L)
  ELBO            <-  c()
  for ( l in 1:L )
  {

    if(!is.null(Y$Y_f)){
      fitted_wc[[l]]        <-    lapply( 1:length(n_wac), function(j) rep( 0, n_wac[[j]]))
      fitted_wc2[[l]]       <-    lapply( 1:length(n_wac), function(j) rep( 0, n_wac[[j]]))
    }
    if(!is.null(Y$Y_u)){
      fitted_uni [[l]]       <-    rep(0, ncol(Y$Y_u))
      fitted_uni2[[l]]       <-    rep(0, ncol(Y$Y_u))
    }


    alpha [[l]]           <-  rep(0, dim(X)[2])
    cs[[l]]               <-  list()
    est_pi [[l]]          <-  get_pi_G_prior(G_prior)
    lBF[[l]]              <-  rep(NA, ncol(X))

  }



  obj <- list( fitted_wc       = fitted_wc,
               fitted_wc2      = fitted_wc2,
               fitted_uni      = fitted_uni,
               fitted_uni2     = fitted_uni2,
               lBF             = lBF,
               KL              = KL,
               ELBO            = ELBO,
               ind_fitted_val  =  ind_fitted_val,
               G_prior         = G_prior,
               alpha_hist      = alpha_hist,
               N               = N,
               n_wac           = n_wac,
               sigma2          = sigma2,
               P               = P,
               alpha           = alpha,
               cs              = cs,
               pip             = pip,
               est_pi          = est_pi,
               est_sd          = est_sd,
               L               = L)

  class(obj) <- "multfsusie"
  return(obj)
}




#' @rdname get_pi
#'
#' @method get_pi multfsusie
#'
#' @export get_pi.multfsusie
#'
#' @export
#'
get_pi.multfsusie <- function(multfsusie.obj, l, ...)
{

  if( l >  length(multfsusie.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  out <- multfsusie.obj$est_pi[[l]]
  return(out)
}





#'@title Update  multfsusie object using the output of EM_pi
#'
#' @param multfsusie.obj a multfsusie object defined by \code{\link{init_multfsusie_obj }} function
#'
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#'
#' @param EM_pi an object of the class "EM_pi" generated by the function \code\link{EM_pi_multfsusie}}
#' @param effect_estimate a list of marginal association generated by \code{cal_Bhat_Shat_multsusie}
#' @param list_indx_lst list of list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution
#'
#' @return multfsusie object
#'
#' @export

update_multfsusie  <- function(multfsusie.obj, l, EM_pi, effect_estimate, list_indx_lst,  ...)
{

  if( l > length(multfsusie.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  if(  "EM_pi_multfsusie"  %!in%  class(EM_pi)  )
  {
    stop("Error EM_pi should be of the class EM_pi_multfsusie")
  }
  multfsusie.obj         <-   update_pi( multfsusie.obj =  multfsusie.obj ,
                                       l             =  l ,
                                       tpi           =  EM_pi$tpi_k)

  multfsusie.obj$G_prior <-   update_prior(get_G_prior(multfsusie.obj) , EM_pi$tpi_k  )
  post_effect <- get_post_effect (G_prior=multfsusie.obj$G_prior ,
                                  effect_estimate,
                                  list_indx_lst )

  if(!is.null(post_effect$res_uni)){
    multfsusie.obj$ fitted_uni[[l]]        <-   post_effect$res_u$Bhat
    multfsusie.obj$ fitted_uni2[[l]]       <-   post_effect$res_u$Shat
  }

  if(!is.null(post_effect$res_f)){
       multfsusie.obj$fitted_wc[[l]]   <-  lapply(1: length( post_effect$res_f) ,
                                             function(k) post_effect$res_f[[k]]$Bhat)

       multfsusie.obj$fitted_wc2[[l]]  <- lapply(1: length( post_effect$res_f) ,
                                            function(k) post_effect$res_f[[k]]$Shat)

      }

  new_alpha      <- cal_zeta (  EM_pi$lBF)
  multfsusie.obj <- update_alpha(multfsusie.obj, l, new_alpha)
  multfsusie.obj <- update_lBF(multfsusie.obj, l, EM_pi$lBF)

  return(multfsusie.obj)
}


#' @rdname update_pi
#'
#' @method update_pi multfsusie
#'
#' @export update_pi.multfsusie
#'
#' @export
#'
update_pi.multfsusie <- function( multfsusie.obj, l, tpi, ...)
{

  if( l > length(multfsusie.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }

  multfsusie.obj$est_pi[[l]] <- tpi
  out <- multfsusie.obj
  class(out) <- "multfsusie"
  return(out)
}


#' @rdname get_G_prior
#'
#' @method get_G_prior multfsusie
#'
#' @export get_G_prior.multfsusie
#'
#' @export
#'
get_G_prior.multfsusie <- function(multfsusie.obj){
  out <- multfsusie.obj$G_prior
  return(out)
}


#' @title Compute posterior mean of the fitted effect
#'
#' @param G_prior a multfsusie_prior object
#'
#' @param effect_estimate an object generated by \link{\code{cal_Bhat_Shat_multfsusie }}
#' @param list_indx_lst list of list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution
#'
#'
#'
#' @return  an object of the same form as effect_estimate, which corresponds to the posterior mean.
get_post_effect <- function(G_prior, effect_estimate, list_indx_lst=NULL){

  out <- list( res_uni = NULL,
               res_f  = NULL)
 if( !is.null(effect_estimate$res_uni)){
   out$res_uni$Bhat  <- do.call( cbind, lapply( 1:length(G_prior$G_prior_u), function( k) get_post_mean_u(G_prior$G_prior_u[[k]],
                                                                                effect_estimate$res_uni$Bhat[,k],
                                                                                effect_estimate$res_uni$Shat[,k]
                                                                                )
                                             )
   )
   out$res_uni$Shat  <- do.call( cbind, lapply( 1:length(G_prior$G_prior_u), function( k) get_post_sd_u(G_prior$G_prior_u[[k]],
                                                                                                          effect_estimate$res_uni$Bhat[,k],
                                                                                                          effect_estimate$res_uni$Shat[,k]
                                                                                                )
                                                )
                                    )
 }
  if( !is.null(effect_estimate$res_f)){
   out$res_f <- lapply( 1:length(G_prior$G_prior_f), function(k)list_post_mean_sd(G_prior$G_prior_f[[k]],
                                                               effect_estimate$res_f[[k]]$Bhat,
                                                               effect_estimate$res_f[[k]]$Shat,
                                                               list_indx_lst[[k]])
                        )
  }
  return( out)
}



#' @title formatting function for output of posterior quantities
#' @description formatting function for output of posterior quantities
#' @param G_prior a mixutre_per_scale prior
#' @param  Bhat matrix of estimated mean
#' @param Shat matrix of estimated sd
#'

list_post_mean_sd <- function(G_prior, Bhat,Shat,  indx_lst)
{
  out <- list (Bhat= post_mat_mean( G_prior ,
                                    Bhat,
                                    Shat,
                                   indx_lst ),
               Shat=post_mat_mean( G_prior ,
                                   Bhat,
                                   Shat,
                                   indx_lst )
               )
  return(out)

}





#' @rdname update_alpha
#'
#' @method update_alpha multfsusie
#'
#' @export update_alpha.multfsusie
#'
#' @export
#'
update_alpha.multfsusie <-  function(multfsusie.obj, l, alpha, ... )
{
  multfsusie.obj$alpha[[l]] <- alpha
  multfsusie.obj$alpha_hist[[ (length(multfsusie.obj$alpha_hist)+1)  ]] <- alpha
  return( multfsusie.obj)
}

#' @rdname update_lBF
#'
#' @method update_lBF multfsusie
#'
#' @export update_lBF.multfsusie
#'
#' @export
#'

update_lBF.multfsusie <- function    (multfsusie.obj,l, lBF, ...)
{
  if(l> multfsusie.obj$L)
  {
    stop("Error: trying to update more effects than the number of specified effect")
  }

  multfsusie.obj$lBF[[l]] <- lBF
  return(multfsusie.obj)
}


#' @rdname cal_partial_resid
#'
#' @method cal_partial_resid multfsusie
#'
#' @export cal_partial_resid.multfsusie
#'
#' @export
#'


cal_partial_resid.multfsusie <- function(multfsusie.obj = multfsusie.obj,l = l, X = X,Y = Y,list_indx_lst  = list_indx_lst){

  L <- multfsusie.obj$L

  update_Y <- list(Y_u=NULL,
                  Y_f=NULL)

  if( !is.null(Y$Y_u)){
    if(L>1){
      id_L <- (1:L)[ - ( (l%%L)+1) ]#Computing residuals R_{l+1} by removing all the effect except effect l+1
      update_Y$Y_u   <- Y$Y_u - Reduce("+", lapply(id_L, function(k)pred_partial_u(multfsusie.obj,k,X)))

    }else{
      id_L <- 1
      update_Y$Y_u   <- Y$Y_u - pred_partial_u(multfsusie.obj,1,X)
    }
  }
  if(!is.null(Y$Y_f)){
         update_Y$Y_f   <-   lapply(1:length(Y$Y_f),function(k)   cal_partial_resid_sub(multfsusie.obj,
                                                         l=l,
                                                         X=X,
                                                         D= Y$Y_f[[k]][,-list_indx_lst[[k]][[length(list_indx_lst[[k]])]]],
                                                         C= Y$Y_f[[k]][,list_indx_lst[[k]][[length(list_indx_lst[[k]])]]],
                                                         indx_lst = list_indx_lst[[k]],
                                                         cord=k
                                                        )
                                        )

              }


 return(update_Y)

}


cal_partial_resid_sub <- function( multfsusie.obj, l, X, D, C, indx_lst,cord){
  L <- multfsusie.obj$L
  if(L>1){
    id_L <- (1:L)[ - ( (l%%L)+1) ]#Computing residuals R_{l+1} by removing all the effect except effect l+1


      update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) (X*rep(multfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %*% (multfsusie.obj$fitted_wc[[l]][[cord]][,-indx_lst[[length(indx_lst)]]])   ) )
      update_C  <-  C - Reduce("+", lapply  ( id_L, function(l) (X*rep(multfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %*% multfsusie.obj$fitted_wc[[l]][[cord]][,indx_lst[[length(indx_lst)]]] ) )
      update_Y  <- cbind(  update_D, update_C)
  }else{
    id_L <- 1


      update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) (X*rep(multfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %*% (multfsusie.obj$fitted_wc[[l]][[cord]][,-indx_lst[[length(indx_lst)]]])   ) )
      update_C  <-  C - Reduce("+", lapply  ( id_L, function(l) (X*rep(multfsusie.obj$alpha[[l]], rep.int(dim(X)[1],dim(X)[2]))) %*% multfsusie.obj$fitted_wc[[l]][[cord]][,indx_lst[[length(indx_lst)]]] ) )
      update_Y  <- cbind(  update_D, update_C)
  }
  return(update_Y)

}

pred_partial_u <- function( multfsusie.obj, l, X )
{
  tbeta <-multfsusie.obj$alpha[[l]] *multfsusie.obj$fitted_uni[[l]]
  pred_l   <- X%*% ( tbeta)
  return(pred_l)
}










